
Функция СоздатьСеть(КоличествоНейроновВходногоСлоя,КоличествоНейроновСкрытогоСлоя,КоличествоНейроновВыходногоСлоя) Экспорт
	
	НачальноеЧисло = 42;
	ГСЧ = Новый ГенераторСлучайныхЧисел(НачальноеЧисло);
  
	
	Сеть  = Новый ТаблицаЗначений;
	Сеть.Колонки.Добавить("Слой");
	Сеть.Колонки.Добавить("Нейрон");
	
	Для н=1 по КоличествоНейроновВходногоСлоя Цикл

		НовСтр = Сеть.Добавить();
		НовСтр.Слой = "Входной";
		НовСтр.Нейрон = СоздатьНейрон(1,ГСЧ);
		
	КонецЦикла;	
	
	Для н=1 по КоличествоНейроновСкрытогоСлоя Цикл

		НовСтр = Сеть.Добавить();
		НовСтр.Слой = "Скрытый";
		НовСтр.Нейрон = СоздатьНейрон(КоличествоНейроновВходногоСлоя,ГСЧ);
		
	КонецЦикла;	

	Для н=1 по КоличествоНейроновВыходногоСлоя Цикл

		НовСтр = Сеть.Добавить();
		НовСтр.Слой = "Выходной";
		НовСтр.Нейрон = СоздатьНейрон(КоличествоНейроновСкрытогоСлоя,ГСЧ);
		
	КонецЦикла;	

	Возврат Сеть;
	
	
КонецФункции

Функция СоздатьНейрон(КоличествоВходов,ГСЧ)	
		Нейрон = Новый Структура;
		СписокВходов= Новый СписокЗначений;
		Для стр=1 по КоличествоВходов Цикл
			СписокВходов.Добавить(0);
		КонецЦикла;
		СписокВесов= Новый СписокЗначений;
		Для стр=1 по КоличествоВходов Цикл
			Если КоличествоВходов=1 Тогда //Это входной нейрон у него вес = 1
			СписокВесов.Добавить(1);	
			Иначе	
			СписокВесов.Добавить(ГСЧ.СлучайноеЧисло(0, 100)/100);
			КонецЕсли;
		КонецЦикла;
		Нейрон.Вставить("Входы",СписокВходов);
		Нейрон.Вставить("Веса",СписокВесов);
		Нейрон.Вставить("Выход",0);
		Нейрон.Вставить("Ошибка",0);

		Возврат Нейрон;
КонецФункции

Процедура feedforward(Сеть,строкаВхода)  Экспорт
	Отбор= Новый Структура;
	Отбор.Вставить("Слой","Входной");
	ВходныеНейроны = Сеть.НайтиСтроки(Отбор);
	НомерВхода = 0;
	ВыходыВходногоСлоя = Новый СписокЗначений;
	
	Для каждого нейрон из ВходныеНейроны Цикл
		НомерВхода=НомерВхода + 1;
		Входы = Новый СписокЗначений;
		Входы.Добавить(строкаВхода["Вход"+СокрЛП(НомерВхода)]);
		нейрон.Нейрон.Входы = Входы;
		
		РешитьНейрон(нейрон.Нейрон,"Входной");
		ВыходыВходногоСлоя.Добавить(нейрон.Нейрон.Выход);
	КонецЦикла;	
	
	Отбор= Новый Структура;
	Отбор.Вставить("Слой","Скрытый");
	НейроныСкрытогоСлоя = Сеть.НайтиСтроки(Отбор);

	ВыходыСкрытогоСлоя = Новый СписокЗначений;
	
	Для каждого нейрон из НейроныСкрытогоСлоя Цикл
		 нейрон.Нейрон.Входы = ВыходыВходногоСлоя;
		 РешитьНейрон(нейрон.Нейрон,"Линейный");
		 ВыходыСкрытогоСлоя.Добавить( нейрон.Нейрон.Выход);
	КонецЦикла;	
	
	Отбор= Новый Структура;
	Отбор.Вставить("Слой","Выходной");
	НейроныВыходногооСлоя = Сеть.НайтиСтроки(Отбор);

	Результат = 0;
	
	Для каждого нейрон из НейроныВыходногооСлоя Цикл
		 нейрон.Нейрон.Входы = ВыходыСкрытогоСлоя;
		 РешитьНейрон(нейрон.Нейрон,"Линейный");
		 Результат = нейрон.Нейрон.Выход;
	КонецЦикла;	

	
	
КонецПроцедуры

Процедура ОбратноеРаспостранениеИОбучение(Сеть,СтрокаВхода) Экспорт
	
	Отбор= Новый Структура;
	Отбор.Вставить("Слой","Выходной");
	НейроныВыходногоСлоя = Сеть.НайтиСтроки(Отбор);

	Результат = 0;
	н = 0;
	
	//расчет ошибки
	
	Для каждого нейрон из НейроныВыходногоСлоя Цикл
		н=н+1;
		ОжидаемыйРезультат = СтрокаВхода["ОжидаемыйВыход"+СокрЛП(н)];
		А= нейрон.Нейрон.Выход;
		нейрон.Нейрон.Ошибка= (ОжидаемыйРезультат-А)*А*(1-А);
	КонецЦикла;	
	
	Отбор= Новый Структура;
	Отбор.Вставить("Слой","Скрытый");
	НейроныСкрытогоСлоя = Сеть.НайтиСтроки(Отбор);

	нн=0;
	Для каждого нейрон из НейроныСкрытогоСлоя Цикл
		ОшибкаСледующегоСлоя= 0;
		Для каждого нейронВыходного Из НейроныВыходногоСлоя Цикл
			ОшибкаСледующегоСлоя = ОшибкаСледующегоСлоя + нейронВыходного.Нейрон.Ошибка*нейронВыходного.Нейрон.Веса.Получить(нн).Значение;
		КонецЦикла;	
		
		А= нейрон.Нейрон.Выход;
		нейрон.Нейрон.Ошибка= ОшибкаСледующегоСлоя*А*(1-А);
		
		нн = нн+1;
	КонецЦикла;	

	// обучение: корректировка весов
	КонстантаОбучения = 0.35;
	
	Для каждого нейрон из НейроныВыходногоСлоя Цикл
		н = 0;
		Для каждого сВес из нейрон.Нейрон.Веса Цикл
			//+ на 1 - поменяй
			
			сВес.Значение = сВес.Значение + КонстантаОбучения* нейрон.Нейрон.Ошибка* НейроныСкрытогоСлоя[н].Нейрон.Выход;
			н=н+1;
		КонецЦикла;	
    КонецЦикла;
	
	
	Отбор= Новый Структура;
	Отбор.Вставить("Слой","Входной");
	НейроныВходногоСлоя = Сеть.НайтиСтроки(Отбор);

	
	
	Для каждого нейрон из НейроныСкрытогоСлоя Цикл
		н = 0;
		Для каждого сВес из нейрон.Нейрон.Веса Цикл
			сВес.Значение = сВес.Значение + КонстантаОбучения* нейрон.Нейрон.Ошибка* НейроныВходногоСлоя[н].Нейрон.Выход;
			н=н+1;
		КонецЦикла;	
    КонецЦикла;
	
	
		
КонецПроцедуры	


Процедура РешитьНейрон (нейрон, ВидНейрона)
	
	
	Сумма = 0;
	СуммаБезВеса = 0;
	Для каждого с из Нейрон.Входы Цикл
		входнойСигнал = с.Значение;
		Вес = Нейрон.Веса.Получить(Нейрон.Входы.Индекс(с)).Значение;
		
		Сумма = Сумма+ входнойСигнал*Вес;
		СуммаБезВеса = СуммаБезВеса+ входнойСигнал*Вес;
			
	КонецЦикла;	
	
	//Если ВидНейрона = "Линейный" Тогда
	Если ВидНейрона = "Входной" Тогда
		Нейрон.Выход =  СуммаБезВеса;
	КонецЕсли;			


	Нейрон.Выход = sigmoid(Сумма);

//Нейрон.Выход = Сумма;
	//КонецЕсли;



КонецПроцедуры	


function sigmoid (x )  
    return 1/(1 + exp(-x))
endfunction

//function normalize(value,INPUT_LOW,INPUT_HIGH,OUTPUT_LOW,OUTPUT_HIGH) export
//  return ((value - INPUT_LOW)  / (INPUT_HIGH - INPUT_LOW))  * (OUTPUT_HIGH - OUTPUT_LOW) + OUTPUT_LOW;
//endfunction
//        
//function deNormalize(value,INPUT_LOW,INPUT_HIGH,OUTPUT_LOW,OUTPUT_HIGH) export  
//	
//                result = ((INPUT_LOW - INPUT_HIGH) * value - OUTPUT_HIGH
//                                * INPUT_LOW + INPUT_HIGH * OUTPUT_LOW)
//                                / (OUTPUT_LOW - OUTPUT_HIGH);
//                return result;
// endfunction

function normalize(value,INPUT_LOW,INPUT_HIGH) export
  return ((value - INPUT_LOW)  / (INPUT_HIGH - INPUT_LOW)) ;
endfunction
        
function deNormalize(value,INPUT_LOW,INPUT_HIGH) export  
	
                result = INPUT_LOW+value*(INPUT_HIGH - INPUT_LOW);
                return result;
 endfunction

 Функция ПосчитатьГраницы(ТабВходнаяВыборка) Экспорт
	 З = Новый Запрос;
	 З.УстановитьПараметр("ВходнаяВыборка",ТабВходнаяВыборка);
	 З.Текст ="ВЫБРАТЬ
	          |	ВходнаяВыборка.Вход1Сигнал,
	          |	ВходнаяВыборка.Вход2Сигнал,
	          |	ВходнаяВыборка.Вход3Сигнал,
	          |	ВходнаяВыборка.Вход4Сигнал,
	          |	ВходнаяВыборка.Вход5Сигнал,
	          |	ВходнаяВыборка.ОжидаемыйВыход1Сигнал,
	          |	ВходнаяВыборка.ОжидаемыйВыход2Сигнал,
	          |	ВходнаяВыборка.ОжидаемыйВыход3Сигнал
	          |ПОМЕСТИТЬ ВходныеДанные
	          |ИЗ
	          |	&ВходнаяВыборка КАК ВходнаяВыборка
	          |;
	          |
	          |////////////////////////////////////////////////////////////////////////////////
	          |ВЫБРАТЬ
	          |	МИНИМУМ(ВходныеДанные.Вход1Сигнал) КАК Минимум,
	          |	МАКСИМУМ(ВходныеДанные.Вход1Сигнал) КАК Максимум,
	          |	""Вход1"" КАК ИмяСтолбца
	          |ИЗ
	          |	ВходныеДанные КАК ВходныеДанные
	          |
	          |ОБЪЕДИНИТЬ ВСЕ
	          |
	          |ВЫБРАТЬ
	          |	МИНИМУМ(ВходныеДанные.Вход2Сигнал),
	          |	МАКСИМУМ(ВходныеДанные.Вход2Сигнал),
	          |	""Вход2""
	          |ИЗ
	          |	ВходныеДанные КАК ВходныеДанные
	          |
	          |ОБЪЕДИНИТЬ ВСЕ
	          |
	          |ВЫБРАТЬ
	          |	МИНИМУМ(ВходныеДанные.Вход3Сигнал),
	          |	МАКСИМУМ(ВходныеДанные.Вход3Сигнал),
	          |	""Вход3""
	          |ИЗ
	          |	ВходныеДанные КАК ВходныеДанные
	          |
	          |ОБЪЕДИНИТЬ ВСЕ
	          |
	          |ВЫБРАТЬ
	          |	МИНИМУМ(ВходныеДанные.Вход4Сигнал),
	          |	МАКСИМУМ(ВходныеДанные.Вход4Сигнал),
	          |	""Вход4""
	          |ИЗ
	          |	ВходныеДанные КАК ВходныеДанные
	          |
	          |ОБЪЕДИНИТЬ ВСЕ
	          |
	          |ВЫБРАТЬ
	          |	МИНИМУМ(ВходныеДанные.Вход5Сигнал),
	          |	МАКСИМУМ(ВходныеДанные.Вход5Сигнал),
	          |	""Вход5""
	          |ИЗ
	          |	ВходныеДанные КАК ВходныеДанные
	          |
	          |ОБЪЕДИНИТЬ ВСЕ
	          |
	          |ВЫБРАТЬ
	          |	МИНИМУМ(ВходныеДанные.ОжидаемыйВыход1Сигнал),
	          |	МАКСИМУМ(ВходныеДанные.ОжидаемыйВыход1Сигнал),
	          |	""ОжидаемыйВыход1""
	          |ИЗ
	          |	ВходныеДанные КАК ВходныеДанные
	          |
	          |ОБЪЕДИНИТЬ ВСЕ
	          |
	          |ВЫБРАТЬ
	          |	МИНИМУМ(ВходныеДанные.ОжидаемыйВыход2Сигнал),
	          |	МАКСИМУМ(ВходныеДанные.ОжидаемыйВыход2Сигнал),
	          |	""ОжидаемыйВыход2""
	          |ИЗ
	          |	ВходныеДанные КАК ВходныеДанные
	          |
	          |ОБЪЕДИНИТЬ ВСЕ
	          |
	          |ВЫБРАТЬ
	          |	МИНИМУМ(ВходныеДанные.ОжидаемыйВыход3Сигнал),
	          |	МАКСИМУМ(ВходныеДанные.ОжидаемыйВыход3Сигнал),
	          |	""ОжидаемыйВыход3""
	          |ИЗ
	          |	ВходныеДанные КАК ВходныеДанные";
	Возврат З.Выполнить().Выгрузить();		  
 КонецФункции	 
 
 
Функция ПолучитьМинимум(ИмяСтолбца) Экспорт
	Возврат ГраницыИнтервалов.Найти(ИмяСтолбца,"ИмяСтолбца").Минимум
КонецФункции	

Функция ПолучитьМаксимум(ИмяСтолбца) Экспорт
	Возврат ГраницыИнтервалов.Найти(ИмяСтолбца,"ИмяСтолбца").Максимум
КонецФункции	

 
Функция ПолучитьМинимумП(Границы,ИмяСтолбца) Экспорт
	Возврат Границы.Найти(ИмяСтолбца,"ИмяСтолбца").Минимум
КонецФункции	

Функция ПолучитьМаксимумП(Границы,ИмяСтолбца) Экспорт
	Возврат Границы.Найти(ИмяСтолбца,"ИмяСтолбца").Максимум
КонецФункции	

